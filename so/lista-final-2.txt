1) Quais as funções básicas da gerência de memória?
Maximizar o número de processos na memória, permitir a execução de programasmaiores que a memória física, 
compartilhamento de dados na memória e proteção damemória utilizada por processo e pelo sistema operacional


2) Considere um sistema computacional com 40Kb de MP que use um SO de 10Kb que
implementa a alocação contigua de memória. Qual a taxa de subutilização da MP para um
programa que ocupe 20Kb de memória?

MP = 40KB
SO = 10KB
programa = 20KB

(10+20)*100/40 = 75%
subutilização = 25%



3) Suponha um sistema computacional de 64Kb de MP que utilize um SO que ocupa 14Kb e que
implementa alocação contigua de memória. Considere também um programa de 90Kb formado
por:
– Módulo principal: 20Kb;
– Outros 3 módulos independentes: (1) 10Kb, (2) 20Kb, (3) 30Kb;

Como o programa poderia ser executado utilizando-se a técnica de overlay?

MP: 64KB
SO: 14KB
modulo principal: 20KB

SO + modulo principal = 34KB
64 - 34 = 30KB restantes
poderia que executar o modulo 1 e 2 simultaneamente ou o módulo 3 sozinho



4) Considerando o exercício anterior, se o módulo de 30 Kb tivesse seu tamanho aumentado para
40 Kb, seria possível executar o programa? Caso não, como poderia ser contornado o problema?

não seria possível, deve aumentar a memória, ou dividir esse módulo em módulos menores




5) Suponha um sistema computacional com 128Kb de MP e que utilize um SO de 64Kb com
alocação particionada estática relocável. Considere também que o sistema foi inicializado com 3
partições: P1 (8Kb), P2 (24Kb), P3 (32Kb). 
Calcule a fragmentação interna da MP após a carga de 3 programas PA, PB e PC:
a) P1: PA (6Kb); P2: PB (20Kb); P3: PC (28Kb)
b) P1: PA (4Kb); P2: PB (16Kb); P3: PC (26Kb)
c) P1: PA (8Kb); P2: PB (24Kb); P3: PC (32Kb)


MP: 128KB
SO: 64KB

P1: 8KB
P2: 24KB
P3: 32KB

a) PA 6KB em P1 que cabe 8kb (fragementação 2kb), PB 20kb em P2 que cabe 24kb (fragmentação 4kb), PC 28kb em P3 que cabe 32kb (fragmentação 2kb)
b) PA 4KB em P1 que cabe 8kb (fragementação 4kb), PB 16kb em P2 que cabe 24kb (fragmentação 8kb), PC 26kb em P3 que cabe 32kb (fragmentação 6kb)
c) PA 8KB em P1 que cabe 8kb (fragementação 0kb), PB 24kb em P2 que cabe 24kb (fragmentação 0kb), PC 32kb em P3 que cabe 32kb (fragmentação 0kb)




1) Considere que os processos da tabela a seguir estão aguardando para serem
executados e que cada um permanecerá na memória pelo tempo especificado. O SO
ocupa uma área de 20Kb no início da memória e gerencia a memória utilizando um
algoritmo de particionamento dinâmico modificado. A memória total disponível no
sistema é de 64Kb e é alocada em blocos múltiplos de 4 Kb. Os processos são
alocados de acordo com a sua identificação (em ordem crescente), e irão aguardar
até obter a memória de que necessitam. Calcule a perda de memória por
fragmentação interna e externa sempre que um processo é retirado ou colocado na
memória. O SO compacta a memória apenas quando existem duas ou mais
partições livres adjacentes.

Processos 	Memória Tempo
1 		30Kb 	5
2 		6Kb	10
3 		36Kb 	5

MP: 64kb
SO: 20kb (ocupa 5 blocos de 4kb cada)

processo 1: 30kb (8 blocos e 2kb de frag. interna)
processo 2: 6kb (2 blocos e 2kb de frag. interna)
processo 3: 36kb (9 blocos e 0kb frag. interna)


*No instante de tempo inicial, com a alocação dos processos por ordem crescente e alocação em múltiplos de 4Kb, a memória terá a seguinte disposição

Sistema Operacional	 20 Kb 
Partição do Processo 1 	 32 Kb (30 Kb úteis) 
Partição do Processo 2 	 8 Kb (6 Kb úteis) 
Área Livre 		 4 Kb

Fragmentação interna na Partição do Processo 1: 2 Kb 
Fragmentação interna na Partição do Processo 2: 2 Kb 
Fragmentação externa: não há

---------

*No instante de tempo 5: O processo 1 termina sua execução.

Sistema Operacional 	20 Kb 
Área Livre 		32 Kb 
Partição do Processo 2 	8 Kb (6 Kb úteis) 
Área Livre 		4 Kb 

Fragmentação interna na Partição do Processo 2: 2 Kb 
Fragmentação externa: 36 Kb 

---------

*No instante de tempo 10: O processo 2 termina sua execução.

Sistema Operacional 	20 Kb 
Partição do Processo 3 	36 Kb (36 Kb úteis) 
Área Livre 		8 Kb

Fragmentação interna na Partição do Processo 3: não há 
Fragmentação externa: não há 


*** Fragmentação externa ocorre em espaços livres e contínuos, porém tão pequenos que não possibilitam a alocação de programas por processos.








2) Considerando as estratégias para escolha da partição dinamicamente, conceitue as
estratégias best-fit e worst-fit especificando prós e contras de cada uma.

best-fit: É escolhida a partição em que o programa deixará o menor espaço possível sobrando o problema é que pequenas áreas livres geradas tem pouca possibilidade de serem utilizadas
worst-fit: É escolhida a partição maior, sempre. Deixa espaços livres maiores, que podem ser reutilizados, o que diminui a fragmentação externa





3) Considere um sistema que possua as seguintes áreas livres na memória principal, ordenadas crescentemente: 
1 - 10 Kb, 2 - 4 Kb, 3 - 20Kb, 4 - 18Kb, 5 - 7Kb, 6 - 9Kb, 7 - 12Kb, 8 - 15Kb. 
Para cada programa a seguir, qual seria a partição alocada utilizando-se as estratégias first-fit, best-fit e worst-fit.
a) 12 Kb
b) 10Kb
c) 9 Kb

first-fit: a) 3
	   b) 1
	   c) 1

best-fit: a) 7
	  b) 1
	  c) 6
	  
worst-fit:
	  a) 3
	  b) 3
	  c) 3





4) Um sistema utiliza alocação particionada dinâmica como mecanismo de gerência de
memória. O SO aloca uma área de memória de 50Kb e possui inicialmente os programas
da tabela:

5Kb Programa A
3Kb Programa B
10Kb Livre
6Kb Programa C
26Kb Livre

Realize as operações a seguir sequencialmente e, mostrando o
estado da memória após cada uma delas. Resolva a questão
utilizando as estratégias best-fit, worst-fit e first-fit.
a) alocar uma área para o programa D (6Kb);
b) liberar a área do programa A;
c) alocar uma área para o programa E (4Kb);


best-fit: 
     a)
	5Kb Programa A
	3Kb Programa B
	6Kb Programa D
	4kb Livre
	6Kb Programa C
	26Kb Livre

     b)
	5Kb Livre
	3Kb Programa B
	6Kb Programa D
	4kb Livre
	6Kb Programa C
	26Kb Livre
	
     c)
     	5Kb Livre
	3Kb Programa B
	6Kb Programa D
	4kb Programa E
	6Kb Programa C
	26Kb Livre


worst-fit:
     a)
	5Kb Programa A
	3Kb Programa B
	10kb Livre
	6Kb Programa C
	6Kb Programa D
	20kb Livre

     b)
	5Kb Livre
	3Kb Programa B
	10kb Livre
	6Kb Programa C
	6Kb Programa D
	20kb Livre
	
     c)
     	5Kb Livre
	3Kb Programa B
	10kb Livre
	6Kb Programa C
	6Kb Programa D
	4kb Programa E
	16kb Livre


first-fit:
     a)
	5Kb Programa A
	3Kb Programa B
	6kb Programa D
	4kb Livre
	6Kb Programa C
	26kb Livre

     b)
	5Kb Livre
	3Kb Programa B
	6kb Programa D
	4kb Livre
	6Kb Programa C
	26kb Livre
	
     c)
     	4Kb Programa E
     	1kb Livre
	3Kb Programa B
	6Kb Programa D
	4kb Livre
	6Kb Programa C
	26kb Livre



5) O que é swapping e para que é utilizada esta técnica?
É uma técnica aplicada a gerência de memória, onde o sistema escolhe um programa residente na MP que é levado da memória para o disco (Swapp out)


6) Por que é importante o uso de um loader com relocação
dinâmica para que a técnica de swapping possa ser
implementada?
O loader com relocação dinâmica permite que os programas possam ser retirados da memória principal 
para a memória secundária e trazidos novamente para a memória principal em qualquer posição.



---------------------------------------------



1) Quais os benefícios oferecidos pela técnica de memória virtual? 
Como este conceito permite que um programa e seus dados 
ultrapassem os limites da memória principal?

Os principais benefícios da técnica de memória virtual são possibilitar que programas e 
dados sejam armazenados independente do tamanho da memória principal, 
permitir um número maior de processos compartilhando a memória principal e 
minimizar o problema da fragmentação. O que possibilita que um programa e seus dados 
ultrapassem os limites da memória principal é a técnica de gerência de memória virtual 
que combina as memórias principal e secundária, estendendo o espaço de endereçamento dos
processos




2) Explique como um endereço virtual de um processo é traduzido para um endereço real na memória principal?
o sistema mantém uma tabela de páginas para cada processo, que é uma estrutura de 
dados interna usada para converter endereços virtuais em seus endereços 
físicos correspondentes



3. Por que o mapeamento deve ser feito em blocos e não sobre células individuais? 
Apresente um exemplo numérico

Porque caso o mapeamento fosse realizado para cada célula na memória principal, 
o espaço ocupado pelas tabelas de mapeamento seria tão grande quanto o espaço de 
endereçamento virtual de cada processo, o que inviabilizaria a implementação do 
mecanismo de memória virtual. Um processo em um sistema computacional com 
arquitetura de 32 bits poderia ter 4 G endereços virtuais e, consequentemente, 
tabelas de mapeamento com 4 G entradas.



4. Qual a principal diferença entre os sistemas que implementam paginação e segmentação? 
A principal diferença entre os dois sistemas está relacionada a forma como o espaço de 
endereçamento virtual está dividido logicamente. Na paginação, o espaço de 
endereçamento está dividido em blocos com o mesmo número de endereços virtuais (páginas), 
enquanto que na segmentação o tamanho dos blocos pode variar (segmentos).  



5. Diferencie página virtual de uma página real. 
Página virtual é um conjunto de endereços virtuais que faz parte do espaço de 
endereçamento virtual de um processo. Página real é um conjunto de endereços 
reais localizado na memória principal. A página real está sempre associada 
a uma página virtual.


6. O que são tabelas de páginas e tabelas de segmentos? 
São tabelas de mapeamento, utilizadas no mecanismo de memória virtual, 
que possibilitam que endereços virtuais sejam traduzidos em endereços reais. 


7. Para que serve o bit de validade nas tabelas de páginas e segmentos? 
Para indicar se a página ou o segmento em questão encontra-se na memória principal


8. O que é um page fault, quando ocorre e quem controla a sua ocorrência? 
Como uma elevada taxa de page fault pode comprometer o sistema operacional? 
O page fault ocorre todas as vezes que um processo faz referência a um endereço virtual 
pertencente a uma página virtual que não se encontra mapeada em uma página real, 
ou seja, não está, no momento, na memória principal. A ocorrência de um page fault é 
verificada através do bit de validade presente na ETP da tabela de páginas referente 
à página virtual. Uma elevada taxa de page fault pode comprometer o desempenho do 
sistema devido ao excessivo overhead de operações de E/S gerados pela paginação.



9) Nos sistemas com paginação, a rotina para tratamento de page faults está residente na memória principal. 
Esta rotina pode ser removida da memória em algum momento? O que aconteceria se esta rotina não estivesse na memória principal durante a ocorrência de um page fault?
Não. A rotina de tratamento de page faults tem que permanecer 
sempre residente na memória principal, caso contrário não será 
possível realizar o page in quando necessário 
(no caso, até mesmo da própria rotina).


10. Descreva como ocorre a fragmentação interna em um sistema que implementa paginação. 
A fragmentação interna em um sistema que implementa paginação só é 
encontrada, realmente, na última página, quando o código 
não ocupa o frame por completo. 


11. Compare as políticas de busca de páginas apresentadas. 
Na paginação por demanda, as páginas dos processos são transferidas da 
memória secundária para a principal apenas quando são referenciadas. 
Este mecanismo é conveniente, na medida em que leva para a memória principal 
apenas as páginas realmente necessárias à execução do programa. 
Desse modo, é possível que partes não executadas do programa, 
como rotinas de tratamento de erros, nunca sejam carregadas para a memória. 

Na paginação antecipada, o sistema carrega para a memória principal, 
além das páginas referenciadas, outras páginas que podem ou não ser 
necessárias ao processo ao longo do seu processamento. Se imaginarmos que o 
programa está armazenado seqüencialmente no disco, existe uma grande 
economia de tempo em levar um conjunto de páginas da memória secundária, ao 
contrário de carregar uma de cada vez. Por outro lado, caso o processo não 
precise das páginas carregadas antecipadamente, o sistema terá perdido 
tempo e ocupado memória principal desnecessariamente



12. Quais as vantagens e desvantagens da alocação de páginas variável comparada à alocação fixa? 
A alocação fixa é simples de ser implementada 
pelo sistema operacional mas não é sempre uma boa opção pois os processos 
possuem necessidades diferentes na alocação de memória. 
A alocação variável é mais flexível mas exige que o sistema operacional 
monitore constantemente o comportamento dos processos gerando maior overhead.



13. Um sistema com gerência de memória virtual por paginação possui 
tamanho de página com 512 posições, espaço de endereçamento virtual com 
512 páginas endereçadas de 0 à 511 e memória real com 10 páginas 
numeradas de 0 à 9. O conteúdo atual da memória real contém apenas 
informações de um único processo e é descrito resumidamente na tabela abaixo:

Endereço Físico  Conteúdo 
1536  		 Página virtual 34 
2048  		 Página virtual 9 
3072  		 Tabela de Páginas 
3584  		 Página Virtual 65 
4608  		 Página Virtual 10


a) Considere que a entrada da tabela de páginas contém, além do endereço do frame, o número da página virtual. Mostre o conteúdo da tabela de páginas deste processo.

npv = 512 paginas = 2 na 9
    
NPV	Frame     
9	4
10	9
34	3
65	7


explicação: npv 9 (pagina virtual 9), frame (paginas da memoria real) 4
endereço 2048 está na pagina 4 da MP pois a pagina 0 vai de 0 a 512, pagina 1 de 512 a 1024, pag 3 de 1024 a 1536 e pag 4 de 1536 a 2048




b) Mostre o conteúdo da tabela de páginas após apágina virtual 49 ser carregada na memória apartir do endereço real 0 e a página virtual 34 ser substituída pela página virtual 12
NPV	Frame     
9	4
10	9
12	3
49	0
65	7


c) Como é o formato do endereço virtual destesistema?

 9     9
npv | desl
|--------|
    18
    
    
O endereço virtual possui 9 bits para endereçar a tabela de páginas e 9 bits para o deslocamento dentro da página.
npv = paginas = 512 = 2 na 9
deslocamento = posições = 512 = 2 na 9




d) Qual endereço físico está associado ao endereço virtual 4613?
O endereço virtual 4613 encontra-se na página virtual 9 (4613/512), que inicia no endereço virtual 4608, o deslocamento é 5 pois 4613-4608 = 5
a pagina virtual 9 esta associada ao endereço fisico 2048, mais o deslocamento = 2053






14. Um sistema operacional implementa gerência de memória virtual por paginação, com frames de 2KB. 
A partir da tabela abaixo, que representa o mapeamento de páginas de um processo em um determinado instante de tempo, responda

Página  Residente  Frame 
0  	Sim  	   20 
1  	Sim        40
2  	Sim  	   100 
3  	Sim        10 
4  	Não  	   50 
5 	Não  	   70 
6  	Sim  	   1000


a) Qual o endereço físico de uma variável que ocupa o último byte da página 3? 
R: Página 3 está mapeada no frame 10 que é o 11° frame da memória principal. Endereço físico: (11 x 2K)-1= 22.527 
outra forma: (10 x 2K) + 2K - 1 = 22527

b) Qual o endereço físico de uma variável que ocupa o primeiro byte da página 2? 
R: Página 2 está mapeada no frame 100 que é o 101° frame da memória principal. Endereço físico:(100 x 2K)= 204.800

c) Qual o endereço físico de uma variável que tem deslocamento 10 na página 3? 
R: Página 3 está mapeada no frame 10 que é o 11° frame da memória principal. O primeiro endereço da página 3 é (10x2K) = 20.480 somando ao deslocamento 10 = 20.490

d) Quais páginas do processo estão na memória? R: 0, 1, 2, 3 e 6





15.Um sistema operacional implementa gerência de memória virtual por paginação. 
Considere endereços virtuais com 16 bits, referenciados por um mesmo processo durante sua execução e sua tabela de páginas abaixo com no máximo 256 entradas, 
sendo que estão representadas apenas as páginas presentes na memória real. 
Indique para cada endereço virtual a seguir a página virtual em que o endereço se encontra, o respectivo deslocamento e se a página encontra-se na memória principal neste momento. 

Página	 Endereço Físico
0 		8 Kb
1 		4 Kb 
2 		24 Kb 
3 		0 Kb 
4 		16 Kb 
5		12 Kb 
9 		20 Kb 
11 		28 Kb 

256 entradas = 2 na 8 entradas
São necessários: 8 bits para referenciar o número da página.

Sobram 8 bits para o deslocamento.

a)(307)10 
307/256 = 1.19
pagina virtual 0 vai de 0 a 255, pagina 1 vai de 256 a 512, 307 está 51 numeros acima do inicio da pagina
Página virtual 1, deslocamento 51 e está na memória

b)(2049)10 
Página virtual 8, deslocamento 1 e não está na memória

c)(2304)10
Página virtual 9, deslocamento 0 e está na memória.





16) Uma memória virtual possui páginas de 1024 endereços, 
existem 8 páginas virtuais e 4096 bytes de memória real. 
A tabela de páginas de um processo está descrita abaixo, 
sendo que o asterisco indica que a página não está na memória principal


Página Virtual	Página Real
0		3
1		1
2		*
3		*
4		2
5		*
6		0
7		*


1024 endereços: 2 na 10
deslocamento = 10

8 paginas = 2 na 3
npv = 3

a) Faça a lista/faixa de todos os endereços virtuais que irão causar page fault. 
Pag. 2 (2048 / 3071), pois existem 1024 por pagina, então pag. 0 vai de 0 a 1024 e assim por diante
pag. 3 (3072 / 4095), 
pag. 5 (5120 / 6143),
pag. 7 (7168 / 8191).

pagina virtual 2: 010.0000000000 - 010.1111111111
2 em binario = 010, deslocamento = 10bits então 010.0000000000 até 010.1111111111

pagina virtual 3: 101.0000000000 - 101.1111111111
3 em binario = 101, deslocamento = 10bits então 101.0000000000 até 101.1111111111

pagina virtual 5: 101.0000000000 - 101.1111111111
pagina virtual 7: 111.0000000000 - 111.1111111111


b) Indique o endereço real correspondente aos seguintes endereços virtuais: 0, 1023, 1024, 6500 e 3728. 
End. Virtual 0 (PV 0 / Desloc 0) End. Real = 3072 + 0 = 3072. pois end. virtual 0 está na pag. virtual 0, e a pag. virtual 0 está na pag. real 3 na MP, pag 3 da MP começa em 3072, por isso 3072 + deslocamento = 3072

End. Virtual 1023 (PV 0 / Desloc 1023) End. Real = 3072 + 1023 = 4095 

End. Virtual 1024 (PV 1 / Desloc 0) End. Real = 1024 + 0 = 1024 

End. Virtual 6500 (PV 6 / Desloc 356) End. Real = 0 + 356 = 356
 
End. Virtual 3728 (PV 3 / Desloc 656)  Page Fault





17) Por que existe a necessidade de uma política de substituição de páginas? Compare políticas as de substituição local e global
porque em algumas situações, quando atinge o seu limite de alocação de frames e necessita alocar novas páginas na MP, o SO deve escolher, dentre as diversas páginas alocadas, qual deverá ser liberada



18. Para que serve o bit de modificação nas tabelas de páginas e segmentos? 
Para indicar se a página ou segmento foi modificado desde o momento em que 
foi carregado pela útlima vez na memória principal. 


19. Como o princípio da localidade viabiliza a implementação da gerência de 
memória virtual por paginação? 
O princípio da localidade é fundamental 
para qualquer sistema que implemente a gerência de memória virtual, 
pois reduz a ocorrência de page/segments faults e, conseqüentemente, 
operações de E/S.  


20. Por que programas não estruturados estão sujeitos a uma alta taxa de page faults? 
Porque o princípio da localidade não se faz presente em códigos desestrurados.



21)Descreva os algoritmos de substituição de páginas FIFO e LRU, apresentando vantagens e desvantagens.
FIFO consiste em substituir a página que foi carregada há mais tempo na memória (a primeira página a entrar é a primeira a sair).
não leva em consideração se a página está sendo muito utilizada ou não, o que não é muito adequado pois pode prejudicar o desempenho do sistema

LRU se a página está sendo intensamente referenciada pelas instruções é muito provável que ela seja novamente referenciada pelas instruções seguintes e, 
de modo oposto, aquelas que não foram acessadas nas últimas instruções também é provável que não sejam acessadas nas próximas




22)Considere um sistema de memória virtual por paginação com endereços virtuais de 24bits e páginas de 2048 endereços. 
Na tabela de páginas a seguir, de um processo em determinado instante de tempo, o bit de validade 1 indica página na memória principal e o bit de modificação 1 indica que a página sofreu alteração. 

Página  BV  BM  Frame 
0  	1   1   30.720 
1  	1   0   0 
2  	1   1   10.240 
3  	0   1   * 
4  	0   0   * 
5  	1   0   6.144

a) Quantos bits possui o campo deslocamento do endereço virtual? 
R: 11 bits pois 2048 = 2 na 11. 

b) Qual o número máximo de entradas que a tabela de páginas pode ter?  
R: 2 na 24 / 2 na 11 = 2 na 13 

c) Qual o endereço físico que ocupa o último endereço da página 2?  
R:10.240+2.047=12.287  

d) Qual o endereço físico traduzido do endereço virtual (00080A)16?  
R: (00080A)16 = 2058, 
página virtual 1, pois a página 0 vai de 0 até 2047, deslocamento 10 e endereço físico igual a 10 pois a pag. virtual 1 está na pag. 0 da MP. 

e) Caso ocorra um page fault e uma das páginas do processo deva ser descartada, quais páginas poderiam sofrer page out?
R: Páginas 0 e 2 pois estão na memória principal e possuem BM=1



23)Considere um sistema com memória virtual que implemente
paginação no qual o limite de frames por processo é 3.
Descreva para os itens a seguir, para os quais é apresentada
uma sequencia de referências a páginas pelo processo, o
número total de page faults para as estratégias de relocação
FIFO e LRU. Indique qual a mais eficaz para cada item.

a. 1 / 2 / 3 / 1 / 4 / 2 / 5 / 3 / 4 / 3

FIFO = Total PF = 5 (melhor política)
1	2	3	1	4	2	5	3	4	3
PF	PF	PF	-  PF (sai 1)	-   PF (sai 2)	-	-	-


LRU = Total PF = 8
1	2	3	1	4		2		5		3		4	3
PF	PF	PF	-  PF (sai 2) 	  PF (sai 3)       PF (sai 1)	   PF (sai 4)      PF (sai 2)   -




b. 1 / 2 / 3 / 1 / 4 / 1 / 3 / 2 / 3 / 3

FIFO = Total PF = 7
1	2	3	1	4		1	3	2		3	3
PF	PF	PF	-  PF (sai 1)	   PF(sai 2)    -   PF(sai 3) 	   PF(sai 4)    -


LRU = Total PF = 5 (melhor política)
1	2	3	1	4	1	3	2	3   3
PF	PF	PF	-   PF(sai 2) 	-       -   PF(sai 4)   -   -





24) Em um sistema paginado, as páginas têm 4Kb endereços, a memória principal possui32Kb e o limite de páginas na memória principal é de 8 páginas.
Um programa faz referência à endereços virtuais situados nas páginas 0, 2, 1, 9, 11, 4, 5, 2, 3, 1, nestaordem. 
Após essa sequência de acessos, a tabela de páginas completa desse programa tem a configuração abaixo, sendo que as entradas em branco correspondem a páginas ausentes

Página	End. Físico
0	8K
1	4K
2	24K
3	0K
4	16K
5	12K
6	*
7	*
8	*
9	20K
10	*
11	28K
12	*
13	*
14	*
15	*

a)  Qual o tamanho (em bits) e o formato do endereço virtual? Justifique
4 bits para o número da página, pois são 16 paginas (pag. 0 a pag. 15) possibilitando endereçar as 16 páginas possíveis, 
e 12 bits para o deslocamento, pois os endereços tem 4KB e pra endereça-los precisa de 12bits possibilitando endereçar os 4K endereços de uma página
16 bits ao todo

b) O processo faz novas referências à endereços virtuais situados nas páginas5, 15, 12, 8 e 0, nesta ordem. 
Complete o quadro a seguir, que ilustra o processamento dessa sequência de acessos utilizando a estratégia de remoção FIFO.
Mostre o estado final da tabela de páginas.

Página Referenciada	Página Removida	Page Fault (sim/não)
5			-		Não
15			0		Sim
12			2		Sim
8			1		Sim
0			9		Sim

ordem de paginas removidas 0,2,1,9 é por causa disso: "faz referência à endereços virtuais situados nas páginas 0, 2, 1, 9, 11, 4, 5, 2, 3, 1, nestaordem. "



25) Em um computador, o endereço virtual é de 16 bits e as páginas têm tamanho de 2Kb endereços. 
O WSL (Working  Set  List) de um processo qualquer é de quatro páginas. Inicialmente, nenhuma página está na memória principal. 
Um programa faz referência aendereços virtuais situados nas páginas 0, 7, 2, 7, 5, 8, 9, 2 e 4, nesta ordem.

a) Quantos bits do endereço virtual destinam-se ao número da página? E ao deslocamento?
2KB = 2048 = 2 na 11, entao precisa de 11 bits
16 - 11 = 5 bits para nº da página


b) Ilustre o comportamento da política de substituição LRU, mostrando, a cada referência, quais páginas estão em memória, os page faults causados e as páginas escolhidas para saírem da memória
Página virtual	Páginas na memória	Page fault?	Página a ser substituída
0		-			Sim		-
7		0			Sim		-
2		7, 0			Sim		-
7		2, 7, 0			Não		-
5		7, 2, 0			Sim		-
8		5, 7, 2, 0		Sim		0
9		8, 5, 7, 2		Sim		2
2		9, 8, 5, 7		Sim		7
4		2, 9, 8, 5		Sim		5
-		4, 2, 9, 8		-		-

*ordem da tabela corresponde a ordem que os endereços são referenciados



26)Um sistema trabalha com gerência de memória virtual por paginação. Para todos os processos do
sistema, o limite de páginas na memória principal é igual a 10. Considere um processo que esteja
executando um programa e em um determinado instante de tempo (T) a sua tabela de páginas possui o
conteúdo abaixo, sendo que o bit de validade igual a 1 indica página na memória principal e bit de
modificação igual a 1 indica que a página sofreu alteração.

Número da Página	BV	BM	Endereço do Frame(hexadecimal)
0			1 	0 	3303A5
1 			1 	0 	AA3200
2 			1 	0 	111111
3 			1	1	BFDCCA
4 			1 	0 	765BFC
5 			1 	0 	654546
6 			1 	1 	B6B7B0
7 			1 	1 	999950
8 			1 	0 	888BB8
9			0	0 	N/A
10 			0 	0 	N/A

Responda as perguntas abaixo, considerando que os seguintes eventos seguintes ocorrerão nos instantes de
tempo indicados:
(T + 1) O processo referencia um endereço na página 9 com page fault.
(T + 2) O processo referencia um endereço na página 1.
(T + 3) O processo referencia um endereço na página 10 com page fault.
(T + 4) O processo referencia um endereço da página 3 com page fault. (tentou acessar a pagina 3 e deu page fault, porque a pagina 3 foi descartada no instante anterior)
(T + 5) O processo referencia um endereço da página 6 com page fault. (tentou acessar a pagina 6 e deu page fault, porque a pagina 6 foi descartada no instante anterior)

a) Em quais instantes de tempo ocorrem um page out?
Nos instantes (T + 3) quando a página 3 é descartada e (T + 4) quando a página 6 é descartada.
Ambas as páginas têm indicativo que sofreram modificação, sendo necessário armazená-las no
arquivo de paginação.


b) Em que instante de tempo o limite de páginas do processo na memória principal é atingido?
No instante (T + 1) pois com o page-in da página 9 chega-se ao limite de 10 páginas na memória principal. 


c) Caso a política de realocação de páginas utilizada seja FIFO, no instante (T + 1), qual a página há mais tempo na memória principal?
A página 3 já que é a primeira a ser descartada. 


d) Como o sistema identifica que no instante de tempo (T + 2) não há ocorrência de page fault? 
Através do bit de validade da página 1






29. Os sistemas operacionais OpenVMS e Windows NT/2000 utilizam dois buffers 
de páginas: um buffer de páginas livres e outro para para páginas modificadas. 
Qual a vantagem de implementar um buffer de páginas modificadas? 
Um buffer de páginas modificadas permite adiar a gravação de páginas 
modificadas que foram selecionadas para realocação e seriam gravadas em 
disco, otimizando o desempenho do sistema.



30. Explique porque páginas pequenas podem aumentar a taxa de paginação. 
Existe uma relação entre o tamanho da página e o número de operações de E/S 
que o sistema deverá executar para carregar as páginas da memória 
secundária para a memória principal. 
Quanto menor o tamanho da página, maior o número de operações de E/S, 
aumentando a taxa de paginação. Por outro lado, páginas pequenas oferecem 
menor fragmentação interna. 



31. A arquitetura VAX-11 utiliza 32 bits para endereçamento e páginas de 
512 bytes. Calcule o número de bits para cada 
parte do endereço virtual, sabendo que o espaço de endereçamento é 
dividido em quatro partes: P0, P1, S0 e S1, sendo que cada um possui sua 
própria tabela de páginas. 
O endereço virtual é formado por NPV1 com 2 bits, 
NPV2 com 21 bits e deslocamento com 9 bits.  



32. Um sistema computacional com espaço de endereçamento de 32 bits, 
utiliza uma tabela de páginas de dois níveis. Os endereços virtuais são 
divididos em um campo de 9 bits para o primeiro nível da tabela, 
outro de 11 bits para o segundo nível e um último campo para o deslocamento. 
Qual o tamanho das páginas? Quantas páginas podem existir no espaço de 
endereçamento virtual (Tanenbaum, 1992)? 

Como existem 12 bits para o deslocamento, temos 2 na 12 endereços, ou seja, 
páginas de 4Kb. Como existem 20 bits para o endereçamento de páginas 
virtuais, temos 2 na 20 páginas possíveis. 



33. Na arquitatura SPARC, o espaço de endereçamento virtual de 4Gb pode ser dividido para cada processo em páginas de  4Kb.  
A busca do endereço real correspondente ao endereço virtual gerado pelo processador envolve, em caso de falha na TLB, três níveis de acesso à memória principal. 
No primeiro nível, é feito um acesso a uma tabela única por processo de 256 entradas.  Essa tabela gera o endereço de uma das 256 possíveis tabelas de nível 2. 
Cada tabela de nível 2 possui 64 entradas e, quando acessada, gera o endereço da tabela de nível 3 que deve ser consultada. 
Essa tabela, que também possui 64 entradas, gera o endereço real procurado. 
As tabelas de nível 1, 2 e 3 formam basicamente uma árvore de busca na memória e vão sendo criadas dinamicamente à medida que novas páginas na memória vão sendo alocadas para aquele processo. 
Qual a vantagem de se ter esse esquema de tabelas em múltiplos níveis, criadas dinamicamente sob demanda, ao invés de uma tabela única criada integralmente quando da carga do processo?  
Justifique sua resposta com um exemplo. 

O endereço virtual é formado por NPV1 com 8 bits, NPV2 com 6 bits, NPV3 com 6 bits e deslocamento com 12 bits. 
Se um processo, quando fosse criado, alocasse todas as tabelas de páginas possíveis, o processo teria tabelas que somadas endereçariam 220 posições. 
Para evitar que a memória principal seja ocupada com páginas que talvez nunca sejam utilizadas, o processo aloca suas tabelas de páginas dinamicamente, conforme a necessidade. 
Por exemplo, quando o processo for criado, apenas uma página de nível 1 (28 posições), uma página de nível 2 (26 posições) e uma página de nível 3 (26 posições) são alocadas inicialmente. 






34. Em um sistema de computação, a busca do endereço real correspondente ao endereço virtual gerado pelo processador envolve, em caso de falha na TLB, dois níveis de acesso à memória principal.
Supondo que não existe memória cache, que a taxa de falha da TLB é de 2%, que o tempo de acesso à TLB é desprezível e que o tempo de acesso à memória principal é de 100 ns, 
calcule o tempo médio em acesso à memória gasto no processamento completo de uma instrução de soma de dois operandos. 
Considere que o primeiro operando é endereçado na memória em modo direto, o segundo operando é endereçado na memória em modo indireto e o operando destino é um registrador interno do processador. 
O tempo de acesso à memória (TAM) é calculado a partir das taxas de acerto e falha na TLB, ou seja, TAM é igual a (0.98% * tempo de acesso à TLB) + 
(número de níveis * (0.02% * tempo de acesso à memória)) = (0.98%*0) + (2 * 38 (0.02%*100)) = 4ns. 

O tempo total para a execução da instrução é igual a soma do tempo de leitura da instrução (4ns), do tempo de leitura do operando “direto” (4ns) 
e do tempo de leitura do operando “indireto” (8ns), totalizando 16 ns.





35. Descreva o mecanismo de tradução de um endereço virtual em um endereço real em sistemas que implementam gerência de memória virtual utilizando segmentação com paginação. Ver item 10.6.  
Segmentos são mapeados através de tabelas de mapeamento de segmentos (TMS);
Os endereços são compostos pelo número de segmento virtual (NSV) e por um deslocamento;
O NSV identifica unicamente um segmento e funciona como um índice para a TMS;
O endereço fisico é obtido combinando o endereço fisico do segmento contido na entrada na tabela de segmentos (ETS) + o deslocamento



36. Na técnica de swapping que critérios o sistema operacional pode utilizar para selecionar os processos que sofrerão swap out? 
Na maioria das políticas, o critério de escolha considera o estado do processo e sua prioridade, buscando dessa forma identificar o processo com as menores chances de serem executados.  


37. Existe fragmentação em sistemas que implementam gerência de memória virtual? Se existe, que tipo de fragmentação é encontrado em sistemas paginados? 
Que tipo de fragmentação é encontrado em sistemas com segmentação? 
O problema da fragmentação existe tanto na gerência de memória virtual por paginação quanto na por segmentação. 
A fragmentação interna ocorre na memória virtual por paginação na última página, caso não seja totalmente ocupada. 
A fragmentação externa ocorre na memória virtual por segmentação em função dos espaços livres deixados entre segmentos alocados na memória principal.  




38. O que é o thrashing em sistemas que implementam memória virtual? 
Thrashing é conseqüência da excessiva paginação/segmentação em sistemas que implementam memória virtual, 
levando o sistema a dedicar mais tempo com operações relacionadas à gerência da memória do que no processamento das aplicações dos usuários. 





//ARQUIVOS

1. O que é um arquivo?
Um arquivo é um conjunto de registros definidos pelo sistema de arquivos, 
tornando seu conceito abstrato e generalista Um arquivo é constituído por informações logicamente relacionadas, 
podendo representar instruções ou dados. Arquivos são gerenciados pelo sistema operacional de maneira a facilitar o acesso dos usuários ao seu conteúdo.  


2. Como arquivos podem ser organizados? 
A forma mais simples de organização de arquivos é através de uma seqüência não-estruturada de bytes, 
na qual o sistema de arquivos não impõe nenhuma estrutura lógica para os dados. 
Alguns sistemas operacionais possuem diferentes organizações de arquivos. 
Neste caso, cada arquivo criado deve seguir um modelo suportado pelo sistema de arquivos. As organizações mais conhecidas e implementadas são a seqüencial, relativa e indexada  


3. Diferencie os métodos de acesso a registros sequencial, direto e indexado. 
No método de acesso seqüencial, a leitura dos registros é realizada na ordem em que são gravados e a gravação de novos registros só é possível no final do arquivo. 
No acesso direto, a leitura/gravação de um registro ocorre diretamente na sua posição, através do número do registro que é a sua posição relativa ao início do arquivo. 
No acesso indexado, o arquivo possui uma área de índice onde existem ponteiros para os diversos registros. 
Sempre que a aplicação deseja acessar um registro, deve ser especificada uma chave através da qual o sistema pesquisará na área de índice o ponteiro correspondente 


4. Qual a função das system calls de E/S? 
Possibilitar o acesso as rotinas de E/S que têm como função disponibilizar uma interface simples e uniforme entre a aplicação e os diversos dipositivos.  



5. Quais as diferentes formas de implementação de uma estrutura de diretórios? 
Estrutura de diretório de nível único, com dois níveis e em árvore. A especificação de cada estrutura esta em 11.3.  



6. Descreva as vantagens e desvantagens das técnicas para gerência de espaços livres. Ver item 11.4.  
Mapa de Bits: um pequeno conjunto de blocos na área reservada do volume é usado para manter um mapa de bits. Nesse mapa, cada bit representa um bloco lógico da partição, 
que pode estar livre ou ocupado
- Problema: consumo de espaço

Lista encadeada: cada bloco livre contém um ponteiro para o próximo bloco livre do disco
 - Problema: busca sempre sequencial, Consome espaço em cada bloco

Tabela de Blocos Livres: tem a localização e o tamanho de um conjunto de blocos livres contíguos no disco


7. O que é alocação contígua de blocos e quais benefícios a desfragmentação pode proporcionar quando esta técnica é utilizada? 
A alocação contígua consiste em armazenar um arquivo em blocos seqüencialmente dispostos no disco. 
A desfragmentação pode solucionar o problema da fragmentação reorganizando todos os arquivos no disco de maneira que só exista um único segmento de blocos livres.  

8. Descreva as vantagens e desvantagens das técnicas de alocação encadeada e indexada na gerência de alocação de espaço em disco. Ver itens 11.5.2 e 11.5.3.  


9. Quais os tipos de proteção de acesso a arquivos existentes e quais suas principais vantagens? 
Senha de acesso, proteção por grupos de usuários e lista de controle de acesso. A vantagem da associação de uma senha de acesso a um arquivo é a simplicidade, 
pois o controle resume-se ao usuário ter conhecimento da senha e, conseqüentemente, ter a liberação do acesso ao arquivo concedida pelo sistema. 
A vantagem da proteção por grupos de usuários é oferecer uma proteção em três níveis: owner (dono), group (grupo) e all (todos). 
Já a lista de controle de acesso tem a vantagem de especifar individualmente para cada arquivo qual usuário e tipo de acesso é concedido. 


10. O que é a técnica denominada buffer cache. 
É a técnica em que o sistema operacional reserva uma área da memória para que se tornem disponíveis caches utilizados em operações de acesso ao disco. 
Quando uma operação é realizada, o sistema verifica se a informação desejada se encontra no buffer cache. 
Em caso positivo, não é necessário o acesso ao disco. Caso o bloco requisitado não se encontre no cache, a operação de E/S é realizada e o cache é atualizado.





//DISPOSITIVOS

1. Explique o modelo de camadas aplicado na gerência de dispositivos. 
A gerência de dispositivos é estruturada através de camadas em um modelo semelhante ao apresentado para o sistema operacional como um todo. 
As camadas de mais baixo nível escondem características dos dispositivos das camadas superiores, oferecendo uma interface simples e confiável ao usuário e suas aplicações. 
As camadas são divididas em dois grupos, onde o primeiro grupo visualiza os diversos tipos de dispositivos do sistema de um modo único, enquanto o segundo é específico para cada dispositivo. 
A maior parte das camadas trabalha de forma independente do dispositivo.  


2. Qual a principal finalidade das rotinas de E/S? 
Tornar as operações de E/S o mais simples possível para o usuário e suas aplicações. 
Com isso, é possível ao usuário realizar operações de E/S sem se preocupar com detalhes do dispositivo que está sendo acessado. 


3. Quais as diferentes formas de um programa chamar rotinas de E/S?
Por comandos de leitura/gravação e chamadas a bibliotecas de rotinas oferecidas por linguagens de alto nível ou diretamente através de uma system call em um código de alto nível.  


4. Quais as principais funções do subsistema de E/S? 
Criar uma interface padronizada com os device drivers e oferecer uma interface uniforme com as camadas superiores. 

5. Qual a principal função de um device driver? 
Implementar a comunicação do subsistema de E/S com os dispositivos, através de controladores.  


6. Por que o sistema de E/S deve criar uma interface padronizada com os device drivers? 
Para que seja possível a inclusão de novos drivers sem a necessidade de alteração da camada de subsistema de E/S.  


7. Explique o funcionamento da técnica de DMA e sua principal vantagem. 
De forma simplificada, uma operação de leitura em disco utilizando DMA teria os seguintes passos. 
A UCP, através do device driver, inicializa os registradores do controlador de DMA e, a partir deste ponto, fica livre para realizar outras atividades. 
O controlador de DMA, por sua vez, solicita ao controlador de disco a transferência do bloco do disco para o seu buffer interno. 
Terminada a transferência, o controlador de disco verifica a existência de erros e, caso não haja erros, o controlador de DMA transfere o bloco para o buffer de E/S na memória principal. 
Ao término da transferência, o controlador de DMA gera uma interrupção avisando ao processador que o dado já encontra-se na memória principal. 
A principal vantagem dessa técnica é evitar que o processador fique ocupado com a transferência do bloco para a memória. 


8. Diferencie os dispositivos de E/S estruturados dos não-estruturados. 
Os dispositivos estruturados (block devices) caracterizam-se por armazenar informações em blocos de tamanho fixo, 
possuindo cada qual um endereço que podem ser lidos ou gravados de forma independente dos demais. Discos magnéticos e ópticos são exemplos de dispositivos estruturados. 
Os dispositivos não-estruturados são aqueles que enviam ou recebem uma seqüência de caracteres sem estar estruturada no formato de um bloco. 
Desse modo, a seqüência de caracteres não é endereçável, não permitindo operações de acesso direto ao dado. 
Dispositivos como terminais, impressoras e interfaces de rede são exemplos de dispositivos não-estruturados.  


9. Qual a principal razão de as operações de E/S em fitas e discos magnéticos serem tão lentas se comparadas a velocidade com que o processador executa instruções? 
A principal razão é o aspecto mecânico presente nas arquiteturas de fitas e discos magnéticos, devido a isso, o tempo total das operações de E/S é extremamente longo, 
se comparado ao número de instruções que o processador pode executar no mesmo intervalo de tempo. 


10. O que são técnicas de redundância em discos magnéticos? 
São técnicas que possibilitam garantir a integridade dos dados mesmo en caso de crash nos discos magnéticos. 


11. Diferencie as técnicas RAID 0, RAID 1 e RAID 5 apresentando vantagens e desvantagens.
raid 0: cada parte de um dado é salva em um disco diferente
raid 1: salva o mesmo dado em varios discos
raid 5: O RAID 5 usa paridade em vez do espelhamento do RAID 0 para redundância de dados. Quando os dados são gravados em uma unidade RAID 5, o sistema calcula a paridade e grava essa paridade na unidade. Enquanto o espelhamento mantém várias cópias de dados em cada volume para usar em caso de falha, o RAID 5 pode reconstruir uma unidade com falha usando os dados de paridade, que não são mantidos em uma única unidade e sim, gravados em todos os discos.














